{"name":"hyperapp","version":"1.2.5","packages":{"hyperapp":{"1.2.5":{"json":{"name":"hyperapp","description":"1 kB JavaScript framework for building web applications.","version":"1.2.5","main":"dist/hyperapp.js","module":"src/index.js","typings":"hyperapp.d.ts","license":"MIT","repository":"hyperapp/hyperapp","homepage":"https://hyperapp.js.org","files":["src","dist","hyperapp.d.ts"],"author":"Jorge Bucaran","keywords":["hyperapp","frontend","framework","virtual dom","vdom"],"scripts":{"test":"jest --coverage --no-cache && tsc -p test/ts","build":"npm run bundle && npm run minify","bundle":"rollup -i src/index.js -o dist/hyperapp.js -m -f umd -n hyperapp","minify":"uglifyjs dist/hyperapp.js -o dist/hyperapp.js -mc pure_funcs=['Object.defineProperty'] --source-map includeSources,url=hyperapp.js.map","prepare":"npm run build","format":"prettier --semi false --write {src,test}/**/*.js {,test/ts/}*.{ts,tsx}","release":"npm run build && npm test && git commit -am $npm_package_version && git tag $npm_package_version && git push && git push --tags && npm publish"},"babel":{"presets":"env","plugins":[["transform-react-jsx",{"pragma":"h"}]]},"devDependencies":{"babel-plugin-transform-react-jsx":"^6.24.1","babel-preset-env":"^1.6.1","jest":"^22.2.0","prettier":"^1.10.2","rollup":"^0.55.3","typescript":"2.7.1","uglify-js":"3.3.9"}},"mainFile":"src/index.js","files":{"/package.json":"{\n  \"name\": \"hyperapp\",\n  \"description\": \"1 kB JavaScript framework for building web applications.\",\n  \"version\": \"1.2.5\",\n  \"main\": \"dist/hyperapp.js\",\n  \"module\": \"src/index.js\",\n  \"typings\": \"hyperapp.d.ts\",\n  \"license\": \"MIT\",\n  \"repository\": \"hyperapp/hyperapp\",\n  \"homepage\": \"https://hyperapp.js.org\",\n  \"files\": [\n    \"src\",\n    \"dist\",\n    \"hyperapp.d.ts\"\n  ],\n  \"author\": \"Jorge Bucaran\",\n  \"keywords\": [\n    \"hyperapp\",\n    \"frontend\",\n    \"framework\",\n    \"virtual dom\",\n    \"vdom\"\n  ],\n  \"scripts\": {\n    \"test\": \"jest --coverage --no-cache && tsc -p test/ts\",\n    \"build\": \"npm run bundle && npm run minify\",\n    \"bundle\": \"rollup -i src/index.js -o dist/hyperapp.js -m -f umd -n hyperapp\",\n    \"minify\": \"uglifyjs dist/hyperapp.js -o dist/hyperapp.js -mc pure_funcs=['Object.defineProperty'] --source-map includeSources,url=hyperapp.js.map\",\n    \"prepare\": \"npm run build\",\n    \"format\": \"prettier --semi false --write {src,test}/**/*.js {,test/ts/}*.{ts,tsx}\",\n    \"release\": \"npm run build && npm test && git commit -am $npm_package_version && git tag $npm_package_version && git push && git push --tags && npm publish\"\n  },\n  \"babel\": {\n    \"presets\": \"env\",\n    \"plugins\": [\n      [\n        \"transform-react-jsx\",\n        {\n          \"pragma\": \"h\"\n        }\n      ]\n    ]\n  },\n  \"devDependencies\": {\n    \"babel-plugin-transform-react-jsx\": \"^6.24.1\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"jest\": \"^22.2.0\",\n    \"prettier\": \"^1.10.2\",\n    \"rollup\": \"^0.55.3\",\n    \"typescript\": \"2.7.1\",\n    \"uglify-js\": \"3.3.9\"\n  }\n}\n","/README.md":"# <img height=24 src=https://cdn.rawgit.com/jorgebucaran/f53d2c00bafcf36e84ffd862f0dc2950/raw/882f20c970ff7d61aa04d44b92fc3530fa758bc0/Hyperapp.svg> Hyperapp\n\n[![Travis CI](https://img.shields.io/travis/hyperapp/hyperapp/master.svg)](https://travis-ci.org/hyperapp/hyperapp)\n[![Codecov](https://img.shields.io/codecov/c/github/hyperapp/hyperapp/master.svg)](https://codecov.io/gh/hyperapp/hyperapp)\n[![npm](https://img.shields.io/npm/v/hyperapp.svg)](https://www.npmjs.org/package/hyperapp)\n[![Slack](https://hyperappjs.herokuapp.com/badge.svg)](https://hyperappjs.herokuapp.com \"Join us\")\n\nHyperapp is a JavaScript micro-framework for building web applications.\n\n* **Minimal** — We have aggressively minimized the concepts you need to understand to be productive while remaining on par with what other frameworks can do.\n* **Pragmatic** — Hyperapp holds firm on the functional programming front when managing your state, but takes a pragmatic approach to allowing for side effects, asynchronous actions, and DOM manipulations.\n* **Standalone** — Do more with less. Hyperapp combines state management with a virtual DOM engine that supports keyed updates & lifecycle events — all with no dependencies.\n\n## Getting Started\n\nOur first example is a counter that can be incremented or decremented. Go ahead and [try it online](https://codepen.io/hyperapp/pen/zNxZLP/left/?editors=0010).\n\n```jsx\nimport { h, app } from \"hyperapp\"\n\nconst state = {\n  count: 0\n}\n\nconst actions = {\n  down: value => state => ({ count: state.count - value }),\n  up: value => state => ({ count: state.count + value })\n}\n\nconst view = (state, actions) => (\n  <div>\n    <h1>{state.count}</h1>\n    <button onclick={() => actions.down(1)}>-</button>\n    <button onclick={() => actions.up(1)}>+</button>\n  </div>\n)\n\napp(state, actions, view, document.body)\n```\n\nHyperapp consists of a two-function API. <samp>hyperapp.h</samp> returns a new [virtual DOM](#view) node tree and <samp>hyperapp.app</samp> [mounts](#mounting) a new application in the specified DOM element. Without an element, it's possible to use Hyperapp \"headless\", which can be useful when unit testing your program.\n\nThis example assumes you are using a JavaScript compiler like [Babel](https://babeljs.io) or [TypeScript](https://www.typescriptlang.org) and a module bundler like [Parcel](https://parceljs.org), [Webpack](https://webpack.js.org), etc. If you are using JSX, all you need to do is install the JSX [transform plugin](https://babeljs.io/docs/plugins/transform-react-jsx) and add the pragma option to your <samp>.babelrc</samp> file.\n\n```json\n{\n  \"plugins\": [[\"transform-react-jsx\", { \"pragma\": \"h\" }]]\n}\n```\n\nJSX is a language syntax extension that lets you write HTML tags interspersed with JavaScript. Because browsers don't understand JSX, we use a compiler to transform it into <samp>hyperapp.h</samp> function calls under the hood.\n\n```jsx\nconst view = (state, actions) =>\n  h(\"div\", {}, [\n    h(\"h1\", {}, state.count),\n    h(\"button\", { onclick: () => actions.down(1) }, \"-\"),\n    h(\"button\", { onclick: () => actions.up(1) }, \"+\")\n  ])\n```\n\nNote that JSX is not required for building applications with Hyperapp. You can use <samp>hyperapp.h</samp> directly and without a compilation step as shown above. Other alternatives to JSX include [@hyperapp/html](https://github.com/hyperapp/html), [hyperx](https://github.com/substack/hyperx), [t7](https://github.com/trueadm/t7) and [ijk](https://github.com/lukejacksonn/ijk).\n\n## Installation\n\nInstall with npm or Yarn.\n\n<pre>\nnpm i <a href=https://www.npmjs.com/package/hyperapp>hyperapp</a>\n</pre>\n\nThen with a module bundler like [Rollup](https://rollupjs.org) or [Webpack](https://webpack.js.org), use as you would anything else.\n\n```js\nimport { h, app } from \"hyperapp\"\n```\n\nIf you don't want to set up a build environment, you can download Hyperapp from a CDN like [unpkg.com](https://unpkg.com/hyperapp) and it will be globally available through the <samp>window.hyperapp</samp> object. We support all ES5-compliant browsers, including Internet Explorer 10 and above.\n\n```html\n<script src=\"https://unpkg.com/hyperapp\"></script>\n```\n\n## Overview\n\nHyperapp applications consist of three interconnected parts: the [state](#state), [view](#view), and [actions](#actions).\n\nOnce initialized, your application executes in a continuous loop, taking in actions from users or from external events, updating the state, and representing changes in the view through a virtual DOM model. Think of an action as a signal that notifies Hyperapp to update the state and schedule the next view redraw. After processing an action, the new state is presented back to the user.\n\n### State\n\nThe state is a plain JavaScript object that describes your entire program. It consists of all the dynamic data that is moved around in the application during its execution. The state cannot be mutated once it is created. We must use actions to update it.\n\n```js\nconst state = {\n  count: 0\n}\n```\n\nLike any JavaScript object, the state can be a nested tree of objects. We refer to nested objects in the state as partial state. A single state tree does not conflict with modularity — see [Nested Actions](#nested-actions) to find out how to update deeply nested objects and split your state and actions.\n\n```js\nconst state = {\n  top: {\n    count: 0\n  },\n  bottom: {\n    count: 0\n  }\n}\n```\n\n### Actions\n\nThe only way to change the state is via actions. An action is a unary function (accepts a single argument) expecting a payload. The payload can be anything you want to pass into the action.\n\nTo update the state, an action must return a partial state object. The new state will be the result of a shallow merge between this object and the current state. Under the hood, Hyperapp wires every function from your actions to schedule a view redraw whenever the state changes.\n\n```js\nconst actions = {\n  setValue: value => ({ value })\n}\n```\n\nInstead of returning a partial state object directly, an action can return a function that takes the current state and actions as arguments and returns a partial state object.\n\n```js\nconst actions = {\n  down: value => state => ({ count: state.count - value }),\n  up: value => state => ({ count: state.count + value })\n}\n```\n\nState updates are always immutable. Do not mutate the state object argument within an action and return it — the results are not what you expect (e.g., the view will not be redrawn).\n\nImmutability enables time-travel debugging, helps prevent introducing hard-to-track-down bugs by making state changes more predictable, and allows cheap memoization of components using shallow equality <samp>===</samp> checks.\n\n#### Asynchronous Actions\n\nActions used for side effects (writing to databases, sending a request to a server, etc.) don't need to have a return value. You may call an action from within another action or callback function. Actions which return a Promise, <samp>undefined</samp> or <samp>null</samp> will not trigger redraws or update the state.\n\n```js\nconst actions = {\n  upLater: value => (state, actions) => {\n    setTimeout(actions.up, 1000, value)\n  },\n  up: value => state => ({ count: state.count + value })\n}\n```\n\nAn action can be an <samp>[async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)</samp> function. Because <samp>async</samp> functions return a Promise, and not a partial state object, you need to call another action in order to update the state.\n\n```js\nconst actions = {\n  upLater: () => async (state, actions) => {\n    await new Promise(done => setTimeout(done, 1000))\n    actions.up(10)\n  },\n  up: value => state => ({ count: state.count + value })\n}\n```\n\n#### Nested Actions\n\nActions can be nested inside namespaces. Updating deeply nested state is as easy as declaring actions inside an object in the same path as the part of the state you want to update.\n\n```jsx\nconst state = {\n  counter: {\n    count: 0\n  }\n}\n\nconst actions = {\n  counter: {\n    down: value => state => ({ count: state.count - value }),\n    up: value => state => ({ count: state.count + value })\n  }\n}\n```\n\n#### Interoperability\n\nThe <samp>app</samp> function returns a copy of your actions where every function is wired to changes in the state. Exposing this object to the outside world can be useful to operate your application from another program or framework, subscribe to global events, listen to mouse and keyboard input, etc.\n\nTo see this in action, modify the example from [Getting Started](#getting-started) to save the wired actions to a variable and try using them. You should see the counter update accordingly.\n\n```jsx\nconst main = app(state, actions, view, document.body)\n\nsetInterval(main.up, 250, 1)\nsetInterval(main.down, 500, 1)\n```\n\nIncluding an action returning the state argument can be useful. Because state updates are always immutable, returning a reference to the current state will not schedule a view redraw.\n\n```jsx\nconst actions = {\n  getState: () => state => state\n}\n```\n\n### View\n\nEvery time your application state changes, the view function is called so that you can specify how you want the DOM to look based on the new state. The view returns your specification in the form of a plain JavaScript object known as a virtual DOM and Hyperapp takes care of updating the actual DOM to match it.\n\n```js\nimport { h } from \"hyperapp\"\n\nexport const view = (state, actions) =>\n  h(\"div\", {}, [\n    h(\"h1\", {}, state.count),\n    h(\"button\", { onclick: () => actions.down(1) }, \"-\"),\n    h(\"button\", { onclick: () => actions.up(1) }, \"+\")\n  ])\n```\n\nA virtual DOM is a description of what a DOM should look like using a tree of nested JavaScript objects known as virtual nodes. Think of it as a lightweight representation of the DOM. In the example, the view function returns and object like this.\n\n```jsx\n{\n  nodeName: \"div\",\n  attributes: {},\n  children: [\n    {\n      nodeName: \"h1\",\n      attributes: {},\n      children: [0]\n    },\n    {\n      nodeName: \"button\",\n      attributes: { ... },\n      children: [\"-\"]\n    },\n    {\n      nodeName:   \"button\",\n      attributes: { ... },\n      children: [\"+\"]\n    }\n  ]\n}\n```\n\nThe virtual DOM model allows us to write code as if the entire document is thrown away and rebuilt on each change, while we only update what actually changed. We try to do this in the least number of steps possible, by comparing the new virtual DOM against the previous one. This leads to high efficiency, since typically only a small percentage of nodes need to change, and changing real DOM nodes is costly compared to recalculating the virtual DOM.\n\nIt may seem wasteful to throw away the old virtual DOM and re-create it entirely on every update — not to mention the fact that at any one time, Hyperapp is keeping two virtual DOM trees in memory, but as it turns out, browsers can create hundreds of thousands of objects very quickly. On the other hand, modifying the DOM is several orders of magnitude more expensive.\n\n### Mounting\n\nTo mount your application in a page, we need a DOM element. This element is referred to as the application container. Applications built with Hyperapp always have a single container.\n\n```jsx\napp(state, actions, view, container)\n```\n\nHyperapp will also attempt to reuse existing elements inside the container enabling SEO optimization and improving your sites time-to-interactive. The process consists of serving a fully rendered page together with your application. Then instead of throwing away the existing content, we'll turn your DOM nodes into an interactive application out of the box.\n\nThis is how we can recycle server-rendered content out the counter example from before. See [Getting Started](#getting-started) for the application code.\n\n```html\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <script defer src=\"bundle.js\"></script>\n</head>\n\n<body>\n  <div>\n    <h1>0</h1>\n    <button>-</button>\n    <button>+</button>\n  </div>\n</body>\n</html>\n```\n\n### Components\n\nA component is a pure function that returns a virtual node. Unlike the view function, components are not wired to your application state or actions. Components are dumb, reusable blocks of code that encapsulate markup, styles and behaviors that belong together.\n\nHere's a taste of how to use components in your application. The application is a typical To-Do manager. Go ahead and [try it online here](https://codepen.io/hyperapp/pen/zNxRLy).\n\n```jsx\nimport { h } from \"hyperapp\"\n\nconst TodoItem = ({ id, value, done, toggle }) => (\n  <li\n    class={done && \"done\"}\n    onclick={() =>\n      toggle({\n        value: done,\n        id: id\n      })\n    }\n  >\n    {value}\n  </li>\n)\n\nexport const view = (state, actions) => (\n  <div>\n    <h1>Todo</h1>\n    <ul>\n      {state.todos.map(({ id, value, done }) => (\n        <TodoItem id={id} value={value} done={done} toggle={actions.toggle} />\n      ))}\n    </ul>\n  </div>\n)\n```\n\nIf you don't know all the attributes that you want to place in a component ahead of time, you can use the [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator). Note that Hyperapp components can return an array of elements as in the following example. This technique lets you group a list of children without adding extra nodes to the DOM.\n\n```jsx\nconst TodoList = ({ todos, toggle }) =>\n  todos.map(todo => <TodoItem {...todo} toggle={toggle} />)\n```\n\n#### Lazy Components\n\nComponents can only receive attributes and children from their parent component. Similarly to the top-level view function, lazy components are passed your application global state and actions. To create a lazy component, return a view function from a regular component.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const Up = ({ by }) => (state, actions) => (\n  <button onclick={() => actions.up(by)}>+ {by}</button>\n)\n\nexport const Down = ({ by }) => (state, actions) => (\n  <button onclick={() => actions.down(by)}>- {by}</button>\n)\n\nexport const Double = () => (state, actions) => (\n  <button onclick={() => actions.up(state.count)}>+ {state.count}</button>\n)\n\nexport const view = (state, actions) => (\n  <main>\n    <h1>{state.count}</h1>\n    <Up by={2} />\n    <Down by={1} />\n    <Double />\n  </main>\n)\n```\n\n#### Children Composition\n\nComponents receive their children elements via the second argument, allowing you and other components to pass arbitrary children down to them.\n\n```jsx\nconst Box = ({ color }, children) => (\n  <div class={`box box-${color}`}>{children}</div>\n)\n\nconst HelloBox = ({ name }) => (\n  <Box color=\"green\">\n    <h1 class=\"title\">Hello, {name}!</h1>\n  </Box>\n)\n```\n\n## Supported Attributes\n\nSupported attributes include [HTML attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes), [SVG attributes](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute), [DOM events](https://developer.mozilla.org/en-US/docs/Web/Events), [Lifecycle Events](#lifecycle-events), and [Keys](#keys). Note that non-standard HTML attribute names are not supported, <samp>onclick</samp> and <samp>class</samp> are valid, but <samp>onClick</samp> or <samp>className</samp> are not.\n\n### Styles\n\nThe <samp>style</samp> attribute expects a plain object rather than a string as in HTML.\nEach declaration consists of a style name property written in <samp>camelCase</samp> and a value. CSS variables are supported too.\n\nIndividual style properties will be diffed and mapped against <samp>[HTMLElement.style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)</samp> property members of the DOM element - you should therefore use the JavaScript style object [property names](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Properties_Reference), e.g. <samp>backgroundColor</samp> rather than <samp>background-color</samp>.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const Jumbotron = ({ text }) => (\n  <div\n    style={{\n      color: \"white\",\n      fontSize: \"32px\",\n      textAlign: center,\n      backgroundImage: `url(${imgUrl})`\n    }}\n  >\n    {text}\n  </div>\n)\n```\n\n### Lifecycle Events\n\nYou can be notified when elements managed by the virtual DOM are created, updated or removed via lifecycle events. Use them for animation, data fetching, wrapping third party libraries, cleaning up resources, etc.\n\nNote that lifecycle events are attached to virtual DOM nodes not to components. Consider adding a key to ensure that the event is attached to a specific DOM element, rather than a recycled one.\n\n#### oncreate\n\nThis event is fired after the element is created and attached to the DOM. Use it to manipulate the DOM node directly, make a network request, create a slide/fade in animation, etc.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const Textbox = ({ placeholder }) => (\n  <input\n    type=\"text\"\n    placeholder={placeholder}\n    oncreate={element => element.focus()}\n  />\n)\n```\n\n#### onupdate\n\nThis event is fired every time we update the element attributes. Use <samp>oldAttributes</samp> inside the event handler to check if any attributes changed or not.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const Textbox = ({ placeholder }) => (\n  <input\n    type=\"text\"\n    placeholder={placeholder}\n    onupdate={(element, oldAttributes) => {\n      if (oldAttributes.placeholder !== placeholder) {\n        // Handle changes here!\n      }\n    }}\n  />\n)\n```\n\n#### onremove\n\nThis event is fired before the element is removed from the DOM. Use it to create slide/fade out animations. Call <samp>done</samp> inside the function to remove the element. This event is not called in its child elements.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const MessageWithFadeout = ({ title }) => (\n  <div onremove={(element, done) => fadeout(element).then(done)}>\n    <h1>{title}</h1>\n  </div>\n)\n```\n\n#### ondestroy\n\nThis event is fired after the element has been removed from the DOM, either directly or as a result of a parent being removed. Use it for invalidating timers, canceling a network request, removing global events listeners, etc.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const Camera = ({ onerror }) => (\n  <video\n    poster=\"loading.png\"\n    oncreate={element => {\n      navigator.mediaDevices\n        .getUserMedia({ video: true })\n        .then(stream => (element.srcObject = stream))\n        .catch(onerror)\n    }}\n    ondestroy={element => element.srcObject.getTracks()[0].stop()}\n  />\n)\n```\n\n### Keys\n\nKeys helps identify nodes every time we update the DOM. By setting the <samp>key</samp> property on a virtual node, you declare that the node should correspond to a particular DOM element. This allow us to re-order the element into its new position, if the position changed, rather than risk destroying it.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const ImageGallery = ({ images }) =>\n  images.map(({ hash, url, description }) => (\n    <li key={hash}>\n      <img src={url} alt={description} />\n    </li>\n  ))\n```\n\nKeys must be unique among sibling-nodes. Don't use an array index as key, if the index also specifies the order of siblings. If the position and number of items in a list is fixed, it will make no difference, but if the list is dynamic, the key will change every time the tree is rebuilt.\n\n```jsx\nimport { h } from \"hyperapp\"\n\nexport const PlayerList = ({ players }) =>\n  players\n    .slice()\n    .sort((player, nextPlayer) => nextPlayer.score - player.score)\n    .map(player => (\n      <li key={player.username} class={player.isAlive ? \"alive\" : \"dead\"}>\n        <PlayerProfile {...player} />\n      </li>\n    ))\n```\n\n## Links\n\n* [Slack](https://hyperappjs.herokuapp.com)\n* [Twitter](https://twitter.com/hyperappJS)\n* [Examples](https://codepen.io/search/pens/?q=hyperapp)\n* [/r/hyperapp](https://www.reddit.com/r/hyperapp)\n\n## License\n\nHyperapp is MIT licensed. See [LICENSE](LICENSE.md).\n","/src/index.js":"export function h(name, attributes) {\n  var rest = []\n  var children = []\n  var length = arguments.length\n\n  while (length-- > 2) rest.push(arguments[length])\n\n  while (rest.length) {\n    var node = rest.pop()\n    if (node && node.pop) {\n      for (length = node.length; length--; ) {\n        rest.push(node[length])\n      }\n    } else if (node != null && node !== true && node !== false) {\n      children.push(node)\n    }\n  }\n\n  return typeof name === \"function\"\n    ? name(attributes || {}, children)\n    : {\n        nodeName: name,\n        attributes: attributes || {},\n        children: children,\n        key: attributes && attributes.key\n      }\n}\n\nexport function app(state, actions, view, container) {\n  var map = [].map\n  var rootElement = (container && container.children[0]) || null\n  var oldNode = rootElement && recycleElement(rootElement)\n  var lifecycle = []\n  var skipRender\n  var isRecycling = true\n  var globalState = clone(state)\n  var wiredActions = wireStateToActions([], globalState, clone(actions))\n\n  scheduleRender()\n\n  return wiredActions\n\n  function recycleElement(element) {\n    return {\n      nodeName: element.nodeName.toLowerCase(),\n      attributes: {},\n      children: map.call(element.childNodes, function(element) {\n        return element.nodeType === 3 // Node.TEXT_NODE\n          ? element.nodeValue\n          : recycleElement(element)\n      })\n    }\n  }\n\n  function resolveNode(node) {\n    return typeof node === \"function\"\n      ? resolveNode(node(globalState, wiredActions))\n      : node != null ? node : \"\"\n  }\n\n  function render() {\n    skipRender = !skipRender\n\n    var node = resolveNode(view)\n\n    if (container && !skipRender) {\n      rootElement = patch(container, rootElement, oldNode, (oldNode = node))\n    }\n\n    isRecycling = false\n\n    while (lifecycle.length) lifecycle.pop()()\n  }\n\n  function scheduleRender() {\n    if (!skipRender) {\n      skipRender = true\n      setTimeout(render)\n    }\n  }\n\n  function clone(target, source) {\n    var out = {}\n\n    for (var i in target) out[i] = target[i]\n    for (var i in source) out[i] = source[i]\n\n    return out\n  }\n\n  function set(path, value, source) {\n    var target = {}\n    if (path.length) {\n      target[path[0]] =\n        path.length > 1 ? set(path.slice(1), value, source[path[0]]) : value\n      return clone(source, target)\n    }\n    return value\n  }\n\n  function get(path, source) {\n    var i = 0\n    while (i < path.length) {\n      source = source[path[i++]]\n    }\n    return source\n  }\n\n  function wireStateToActions(path, state, actions) {\n    for (var key in actions) {\n      typeof actions[key] === \"function\"\n        ? (function(key, action) {\n            actions[key] = function(data) {\n              var result = action(data)\n\n              if (typeof result === \"function\") {\n                result = result(get(path, globalState), actions)\n              }\n\n              if (\n                result &&\n                result !== (state = get(path, globalState)) &&\n                !result.then // !isPromise\n              ) {\n                scheduleRender(\n                  (globalState = set(path, clone(state, result), globalState))\n                )\n              }\n\n              return result\n            }\n          })(key, actions[key])\n        : wireStateToActions(\n            path.concat(key),\n            (state[key] = clone(state[key])),\n            (actions[key] = clone(actions[key]))\n          )\n    }\n\n    return actions\n  }\n\n  function getKey(node) {\n    return node ? node.key : null\n  }\n\n  function eventListener(event) {\n    return event.currentTarget.events[event.type](event)\n  }\n\n  function updateAttribute(element, name, value, oldValue, isSvg) {\n    if (name === \"key\") {\n    } else if (name === \"style\") {\n      for (var i in clone(oldValue, value)) {\n        var style = value == null || value[i] == null ? \"\" : value[i]\n        if (i[0] === \"-\") {\n          element[name].setProperty(i, style)\n        } else {\n          element[name][i] = style\n        }\n      }\n    } else {\n      if (name[0] === \"o\" && name[1] === \"n\") {\n        name = name.slice(2)\n\n        if (element.events) {\n          if (!oldValue) oldValue = element.events[name]\n        } else {\n          element.events = {}\n        }\n\n        element.events[name] = value\n\n        if (value) {\n          if (!oldValue) {\n            element.addEventListener(name, eventListener)\n          }\n        } else {\n          element.removeEventListener(name, eventListener)\n        }\n      } else if (name in element && name !== \"list\" && !isSvg) {\n        element[name] = value == null ? \"\" : value\n      } else if (value != null && value !== false) {\n        element.setAttribute(name, value)\n      }\n\n      if (value == null || value === false) {\n        element.removeAttribute(name)\n      }\n    }\n  }\n\n  function createElement(node, isSvg) {\n    var element =\n      typeof node === \"string\" || typeof node === \"number\"\n        ? document.createTextNode(node)\n        : (isSvg = isSvg || node.nodeName === \"svg\")\n          ? document.createElementNS(\n              \"http://www.w3.org/2000/svg\",\n              node.nodeName\n            )\n          : document.createElement(node.nodeName)\n\n    var attributes = node.attributes\n    if (attributes) {\n      if (attributes.oncreate) {\n        lifecycle.push(function() {\n          attributes.oncreate(element)\n        })\n      }\n\n      for (var i = 0; i < node.children.length; i++) {\n        element.appendChild(\n          createElement(\n            (node.children[i] = resolveNode(node.children[i])),\n            isSvg\n          )\n        )\n      }\n\n      for (var name in attributes) {\n        updateAttribute(element, name, attributes[name], null, isSvg)\n      }\n    }\n\n    return element\n  }\n\n  function updateElement(element, oldAttributes, attributes, isSvg) {\n    for (var name in clone(oldAttributes, attributes)) {\n      if (\n        attributes[name] !==\n        (name === \"value\" || name === \"checked\"\n          ? element[name]\n          : oldAttributes[name])\n      ) {\n        updateAttribute(\n          element,\n          name,\n          attributes[name],\n          oldAttributes[name],\n          isSvg\n        )\n      }\n    }\n\n    var cb = isRecycling ? attributes.oncreate : attributes.onupdate\n    if (cb) {\n      lifecycle.push(function() {\n        cb(element, oldAttributes)\n      })\n    }\n  }\n\n  function removeChildren(element, node) {\n    var attributes = node.attributes\n    if (attributes) {\n      for (var i = 0; i < node.children.length; i++) {\n        removeChildren(element.childNodes[i], node.children[i])\n      }\n\n      if (attributes.ondestroy) {\n        attributes.ondestroy(element)\n      }\n    }\n    return element\n  }\n\n  function removeElement(parent, element, node) {\n    function done() {\n      parent.removeChild(removeChildren(element, node))\n    }\n\n    var cb = node.attributes && node.attributes.onremove\n    if (cb) {\n      cb(element, done)\n    } else {\n      done()\n    }\n  }\n\n  function patch(parent, element, oldNode, node, isSvg) {\n    if (node === oldNode) {\n    } else if (oldNode == null || oldNode.nodeName !== node.nodeName) {\n      var newElement = createElement(node, isSvg)\n      parent.insertBefore(newElement, element)\n\n      if (oldNode != null) {\n        removeElement(parent, element, oldNode)\n      }\n\n      element = newElement\n    } else if (oldNode.nodeName == null) {\n      element.nodeValue = node\n    } else {\n      updateElement(\n        element,\n        oldNode.attributes,\n        node.attributes,\n        (isSvg = isSvg || node.nodeName === \"svg\")\n      )\n\n      var oldKeyed = {}\n      var newKeyed = {}\n      var oldElements = []\n      var oldChildren = oldNode.children\n      var children = node.children\n\n      for (var i = 0; i < oldChildren.length; i++) {\n        oldElements[i] = element.childNodes[i]\n\n        var oldKey = getKey(oldChildren[i])\n        if (oldKey != null) {\n          oldKeyed[oldKey] = [oldElements[i], oldChildren[i]]\n        }\n      }\n\n      var i = 0\n      var k = 0\n\n      while (k < children.length) {\n        var oldKey = getKey(oldChildren[i])\n        var newKey = getKey((children[k] = resolveNode(children[k])))\n\n        if (newKeyed[oldKey]) {\n          i++\n          continue\n        }\n\n        if (newKey == null || isRecycling) {\n          if (oldKey == null) {\n            patch(element, oldElements[i], oldChildren[i], children[k], isSvg)\n            k++\n          }\n          i++\n        } else {\n          var keyedNode = oldKeyed[newKey] || []\n\n          if (oldKey === newKey) {\n            patch(element, keyedNode[0], keyedNode[1], children[k], isSvg)\n            i++\n          } else if (keyedNode[0]) {\n            patch(\n              element,\n              element.insertBefore(keyedNode[0], oldElements[i]),\n              keyedNode[1],\n              children[k],\n              isSvg\n            )\n          } else {\n            patch(element, oldElements[i], null, children[k], isSvg)\n          }\n\n          newKeyed[newKey] = children[k]\n          k++\n        }\n      }\n\n      while (i < oldChildren.length) {\n        if (getKey(oldChildren[i]) == null) {\n          removeElement(element, oldElements[i], oldChildren[i])\n        }\n        i++\n      }\n\n      for (var i in oldKeyed) {\n        if (!newKeyed[i]) {\n          removeElement(element, oldKeyed[i][0], oldKeyed[i][1])\n        }\n      }\n    }\n    return element\n  }\n}\n"},"dependencies":{},"peerDependencies":{},"unresolved":{}}}}}