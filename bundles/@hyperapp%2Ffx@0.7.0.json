{"name":"@hyperapp/fx","version":"0.7.0","packages":{"@hyperapp/fx":{"0.7.0":{"json":{"name":"@hyperapp/fx","version":"0.7.0","description":"Effects as data for Hyperapp","main":"dist/hyperappFx.js","module":"src/index.js","repository":{"type":"git","url":"git+https://github.com/hyperapp/fx.git"},"peerDependencies":{"hyperapp":"^1.2.0"},"devDependencies":{"babel-preset-env":"=1.6.1","eslint":"=4.19.0","eslint-plugin-compat":"=2.2.0","hyperapp":"=1.2.0","jest":"=22.4.2","prettier":"=1.11.1","rollup":"=0.57.1","uglify-js":"=3.3.15"},"scripts":{"clean":"npx rimraf coverage dist node_modules","format":"prettier --write '{src,test}/**/*.js'","format:check":"prettier --list-different {src,test}/**/*.js","lint":"eslint {src,test}/**/*.js","test":"jest --coverage --no-cache","bundle":"rollup -i src/index.js -o dist/hyperappFx.js -m -f umd -n hyperappFx","minify":"uglifyjs dist/hyperappFx.js -o dist/hyperappFx.js -mc pure_funcs=['Object.defineProperty'] --source-map includeSources,url=hyperappFx.js.map","check":"npm run format:check && npm run lint && npm t","build":"npm run check && npm run bundle && npm run minify","prepare":"npm run build","release":"./pre-flight-tests && npm run clean && npm i && git tag $npm_package_version && git push && git push --tags && npm publish"},"prettier":{"semi":false},"babel":{"presets":"env"},"eslintConfig":{"extends":"eslint:recommended","plugins":["compat"],"parserOptions":{"sourceType":"module"},"env":{"browser":true},"rules":{"no-use-before-define":"error","compat/compat":"error"},"settings":{"polyfills":["fetch"]}},"browserslist":["IE 10"],"author":"Wolfgang Wedemeyer <wolf@okwolf.com>","license":"MIT","bugs":{"url":"https://github.com/hyperapp/fx/issues"},"homepage":"https://github.com/hyperapp/fx"},"mainFile":"src/index.js","files":{"/package.json":"{\n  \"name\": \"@hyperapp/fx\",\n  \"version\": \"0.7.0\",\n  \"description\": \"Effects as data for Hyperapp\",\n  \"main\": \"dist/hyperappFx.js\",\n  \"module\": \"src/index.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/hyperapp/fx.git\"\n  },\n  \"peerDependencies\": {\n    \"hyperapp\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"babel-preset-env\": \"=1.6.1\",\n    \"eslint\": \"=4.19.0\",\n    \"eslint-plugin-compat\": \"=2.2.0\",\n    \"hyperapp\": \"=1.2.0\",\n    \"jest\": \"=22.4.2\",\n    \"prettier\": \"=1.11.1\",\n    \"rollup\": \"=0.57.1\",\n    \"uglify-js\": \"=3.3.15\"\n  },\n  \"scripts\": {\n    \"clean\": \"npx rimraf coverage dist node_modules\",\n    \"format\": \"prettier --write '{src,test}/**/*.js'\",\n    \"format:check\": \"prettier --list-different {src,test}/**/*.js\",\n    \"lint\": \"eslint {src,test}/**/*.js\",\n    \"test\": \"jest --coverage --no-cache\",\n    \"bundle\": \"rollup -i src/index.js -o dist/hyperappFx.js -m -f umd -n hyperappFx\",\n    \"minify\": \"uglifyjs dist/hyperappFx.js -o dist/hyperappFx.js -mc pure_funcs=['Object.defineProperty'] --source-map includeSources,url=hyperappFx.js.map\",\n    \"check\": \"npm run format:check && npm run lint && npm t\",\n    \"build\": \"npm run check && npm run bundle && npm run minify\",\n    \"prepare\": \"npm run build\",\n    \"release\": \"./pre-flight-tests && npm run clean && npm i && git tag $npm_package_version && git push && git push --tags && npm publish\"\n  },\n  \"prettier\": {\n    \"semi\": false\n  },\n  \"babel\": {\n    \"presets\": \"env\"\n  },\n  \"eslintConfig\": {\n    \"extends\": \"eslint:recommended\",\n    \"plugins\": [\n      \"compat\"\n    ],\n    \"parserOptions\": {\n      \"sourceType\": \"module\"\n    },\n    \"env\": {\n      \"browser\": true\n    },\n    \"rules\": {\n      \"no-use-before-define\": \"error\",\n      \"compat/compat\": \"error\"\n    },\n    \"settings\": {\n      \"polyfills\": [\n        \"fetch\"\n      ]\n    }\n  },\n  \"browserslist\": [\n    \"IE 10\"\n  ],\n  \"author\": \"Wolfgang Wedemeyer <wolf@okwolf.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/hyperapp/fx/issues\"\n  },\n  \"homepage\": \"https://github.com/hyperapp/fx\"\n}\n","/README.md":"# <img height=24 src=https://cdn.rawgit.com/jorgebucaran/f53d2c00bafcf36e84ffd862f0dc2950/raw/882f20c970ff7d61aa04d44b92fc3530fa758bc0/Hyperapp.svg> Hyperapp FX\n\n[![Build Status](https://travis-ci.org/hyperapp/fx.svg?branch=master)](https://travis-ci.org/hyperapp/fx)\n[![codecov](https://codecov.io/gh/hyperapp/fx/branch/master/graph/badge.svg)](https://codecov.io/gh/hyperapp/fx)\n[![npm](https://img.shields.io/npm/v/@hyperapp/fx.svg)](https://www.npmjs.org/package/@hyperapp/fx)\n[![Slack](https://hyperappjs.herokuapp.com/badge.svg)](https://hyperappjs.herokuapp.com \"Join us\")\n\nA [Hyperapp](https://github.com/hyperapp/hyperapp) higher-order `app` enabling you to write your [_effects as data_](https://youtu.be/6EdXaWfoslc), inspired by [Elm Commands](https://guide.elm-lang.org/architecture/effects). Using _effects as data_ will give your app benefits in several areas.\n\n* **Purity** — All of your actions become pure functions, since you are merely returning data describing the effect(s) to run on your behalf later, rather than directly performing them yourself.\n* **Testing** — pure functions are amazingly easy to test, since they always return the same data for the same arguments.\n* **Debugging** — data is more useful for troubleshooting at runtime since it can be logged or serialized and transmitted for remote forensics. Debug async and other effectful code without touching a debugger.\n\n## Getting Started\n\nHere's a taste of how to use two of the most common effects for firing actions and making HTTP requests. The app displays inspiring quotes about design, fetching a new quote each time the user clicks on the current one. Go ahead and [try it online here](https://codepen.io/okwolf/pen/QQYaad?editors=0010).\n\n```js\nimport { h, app } from \"hyperapp\"\nimport { withFx, http, action } from \"@hyperapp/fx\"\n\nconst state = {\n  quote: \"Click here for quotes\"\n}\n\nconst actions = {\n  getQuote: () => [\n    action(\"setQuote\", \"...\"),\n    http(\n      \"https://quotesondesign.com/wp-json/posts?filter[orderby]=rand&filter[posts_per_page]=1\",\n      \"quoteFetched\"\n    )\n  ],\n  quoteFetched: ([{ content }]) => action(\"setQuote\", content),\n  setQuote: quote => ({ quote })\n}\n\nconst view = state => <h1 onclick={action(\"getQuote\")}>{state.quote}</h1>\n\nwithFx(app)(state, actions, view, document.body)\n```\n\n## Installation\n\nInstall with npm or Yarn.\n\n<pre>\nnpm i <a href=\"https://www.npmjs.com/package/@hyperapp/fx\">@hyperapp/fx</a>\n</pre>\n\nThen with a module bundler like [parcel](https://github.com/parcel-bundler/parcel), [rollup](https://github.com/rollup/rollup) or [webpack](https://github.com/webpack/webpack), use as you would anything else.\n\n```js\nimport { withFx } from \"@hyperapp/fx\"\n```\n\nIf you don't want to set up a build environment, you can download Hyperapp FX from a CDN like [unpkg.com](https://unpkg.com/@hyperapp/fx) and it will be globally available through the `window.hyperappFx` object.\n\n```html\n<script src=\"https://unpkg.com/@hyperapp/fx\"></script>\n```\n\n## Overview\n\n### `withFx`\n\n```js\nEffectsConfig = {\n  [effectName]: (\n    props: object,\n    getAction: (name: string) => Action\n  ) => undefined\n}\nwithFx = App => App | EffectsConfig => App => App\n```\n\nThis higher-order `app` function enables `actions` to return arrays which later will be run as effects.\n\nExample:\n\n```js\nimport { withFx } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => [\n    // ... effects go here\n  ],\n  bar: () => // or a single effect can go here\n}\n\nwithFx(app)(state, actions).foo()\n```\n\n#### Custom effects\n\nFor custom effects pass an object to `withFx` before composing with your `app`:\n\n```js\nimport { withFx } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  /*\n    You will probably want to write a helper function for returning these\n    similar to the built-in effects\n  */\n  foo: () => [\n    /*\n      type of effect for effects data\n      must match key used in custom effect object below\n    */\n    \"custom\",\n    {\n      // ... props go here\n    }\n  ]\n}\n\nwithFx({\n  // key in this object must match type used in effect data above\n  custom(props, getAction) {\n    /*\n      use props to get the props used when creating the effect\n      use getAction for firing actions when appropriate\n    */\n  }\n})(app)(state, actions).foo()\n```\n\nReusing an existing effect type will override the built-in one.\n\n### Effects data\n\n```js\nEffectTuple = [type: string, props: object]\nEffect = EffectTuple | EffectTuple[] | Effect[]\n```\n\nEffects are always represented as arrays. For a single effect this array represents a tuple containing the effect type string and an object containing the properties of this effect. For multiple effects each array element is either an effect tuple or an array of these tuples, which may be nested. This means that effects are composeable. Empty arrays are treated as a no-op effect and skipped.\n\n### `action`\n\n```js\naction = (name: string, data?: any) => EffectTuple\n```\n\nDescribes an effect that will fire another action, optionally with `data`.\n\nExample:\n\n```js\nimport { withFx, action } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => [\n    action(\"bar\", { message: \"hello\" }),\n    action(\"baz\", { message: \"hola\" }),\n    // ... other effects\n  ],\n  bar: data => {\n    // data will have { message: \"hello\" }\n  },\n  baz: data => {\n    // data will have { message: \"hola\" }\n  }\n}\n\nwithFx(app)(state, actions).foo()\n```\n\nNote that you may also use a single action effect without an array wrapper and that nested `actions` may be called by separating the slices with dots:\n\n```js\nimport { withFx, action } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => action(\"bar.baz\", { message: \"hello\" }),\n  bar: {\n    baz: data => {\n      // data will have { message: \"hello\" }\n    }\n  }\n}\n\nwithFx(app)(state, actions).foo()\n```\n\nThis same convention follows for all the other effects as well.\n\nAlso note that `action` (and other effects) may be used for handler props in your `view`:\n\n```js\nimport { withFx, action } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: data => {\n    /*\n      data will have { message: \"hello\" }\n      when the button is clicked\n    */\n  }\n}\n\nconst view = () =>\n  h(\"button\", {\n    onclick: action(\"foo\", { message: \"hello\" })\n  })\n\nwithFx(app)(state, actions, view, document.body)\n```\n\n### `frame`\n\n```js\nframe = (action: string) => EffectTuple\n```\n\nDescribes an effect that will call an action from inside [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame), which is also where the render triggered by the action will run. A relative timestamp will be provided as the action `data`. If you wish to have an action that continuously updates the `state` and rerenders inside of `requestAnimationFrame` (such as for a game), remember to include another `frame` effect in your return.\n\nExample:\n\n```js\nimport { withFx, action, frame } from \"@hyperapp/fx\"\n\nconst state = {\n  time: 0,\n  delta: 0\n}\n\nconst actions = {\n  init: () => frame(\"update\"),\n  update: time => [\n    action(\"incTime\", time),\n\n    /*\n      ...\n      Other actions to update the state based on delta time\n      ...\n\n      End with a recursive frame effect to perform the next update\n    */\n    frame(\"update\")\n  ],\n  incTime: time => ({ time: lastTime, delta: lastDelta }) => ({\n    time,\n    delta: time && lastTime ? time - lastTime : lastDelta\n  })\n}\n\nwithFx(app)(state, actions).init()\n```\n\n### `delay`\n\n```js\ndelay = (duration: number, action: string, data?: any) => EffectTuple\n```\n\nDescribes an effect that will call an action after a delay using [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout), optionally with `data`.\n\nExample:\n\n```js\nimport { withFx, delay } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  startTimer: () => delay(60000, \"alarm\", { name: \"minute timer\" }),\n  alarm: data => {\n    /*\n      This action will run after a minute delay\n      data will have { name: \"minute timer\" }\n    */\n  }\n}\n\nwithFx(app)(state, actions).startTimer()\n```\n\n### `time`\n\n```js\ntime = (action: string) => EffectTuple\n```\n\nDescribes an effect that will provide the current timestamp to an action using [`performance.now`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). The timestamp will be provided as the action `data`.\n\nExample:\n\n```js\nimport { withFx, time } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => time(\"bar\"),\n  bar: timestamp => {\n    // use timestamp\n  }\n}\n\nwithFx(app)(state, action).foo()\n```\n\n### `log`\n\n```js\nlog = (...args: any[]) => EffectTuple\n```\n\nDescribes an effect that will call [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/Console/log) with arguments. Useful for development and debugging. Not recommended for production.\n\nExample:\n\n```js\nimport { withFx, log } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => log(\n    \"string arg\",\n    { object: \"arg\" },\n    [\"list\", \"of\", \"args\"],\n    someOtherArg\n  )\n}\n\nwithFx(app)(state, actions).foo()\n```\n\n### `http`\n\n```js\nhttp = (url: string, action: string, options?: object) => EffectTuple\n```\n\nDescribes an effect that will send an HTTP request using [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch) and then call an action with the response. If you are using a browser from the Proterozoic Eon like Internet Explorer you will want one of the [available](https://github.com/developit/unfetch) `fetch` [polyfills](https://github.com/github/fetch). An optional `options` parameter supports the same [options as `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#Parameters) plus the following additional properties:\n\n| Property   | Usage                                                                                                                                              | Default                            |\n|------------|----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------|\n| `response` | Specify which [method to use on the response body](https://developer.mozilla.org/en-US/docs/Web/API/Body#Methods).                                 | `\"json\"`                           |\n| `error`    | Action to call if there is a problem making the request or a [not-ok](https://developer.mozilla.org/en-US/docs/Web/API/Response/ok) HTTP response. | Same action as defined for success |\n\nExample HTTP GET request with a JSON response:\n\n```js\nimport { withFx, http } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => http(\"/data\", \"dataFetched\"),\n  dataFetched: data => {\n    // data will have the JSON-decoded response from /data\n  }\n}\n\nwithFx(app)(state, actions).foo()\n```\n\nExample HTTP GET request with a text response:\n\n```js\nimport { withFx, http } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => http(\n    \"/data/name\",\n    \"textFetched\",\n    { response: \"text\" }\n  ),\n  textFetched: data => {\n    // data will have the response text from /data\n  }\n}\n\nwithFx(app)(state, actions).foo()\n```\n\nExample HTTP POST request using JSON body and response that handles errors:\n\n```js\nimport { withFx, http } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  login: form => http(\n    \"/login\",\n    \"loginComplete\",\n    {\n      method: \"POST\",\n      body: form,\n      error: \"loginError\"\n    }\n  ),\n  loginComplete: loginResponse => {\n    // loginResponse will have the JSON-decoded response from POSTing to /login\n  },\n  loginError: error => {\n    // please handle your errors...\n  }\n}\n\nwithFx(app)(state, actions).login()\n```\n\n### `event`\n\n```js\nevent = (action: string) => EffectTuple\n```\n\nDescribes an effect that will capture [DOM Event](https://developer.mozilla.org/en-US/docs/Web/Events) data when attached to a handler in your `view`. The originally fired event will be provided as the action `data`.\n\n```js\nimport { withFx, event } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  click: clickEvent => {\n    // clickEvent has the props of the click event\n  }\n}\n\nconst view = () =>\n  h(\"button\", {\n    onclick: event(\"click\")\n  })\n\nwithFx(app)(state, actions, view, document.body)\n```\n\n[Custom effects](#custom-effects) recieve an `event` prop if they were fired from within an event handler. This event value is particularly useful when implementing logic for accessing the current DOM element in [Hyperapp lifecyle events](https://github.com/hyperapp/hyperapp#lifecycle-events) such as `oncreate` and `ondestroy`.\n\nExample custom effect to focus an input on create:\n\n```js\nimport { withFx, event } from \"@hyperapp/fx\"\n\nconst focus = () => [\"focus\"];\nconst fx = {\n  focus({ event }) {\n    // Side effects are isolated to only within fx\n    event.focus();\n  }\n};\n\nconst state = {\n  text: \"hi\"\n};\n\nconst actions = {\n  type: ({ target: { value: text } }) => ({ text })\n};\n\nconst view = state => (\n  <main>\n    <h1>{state.text}</h1>\n    <input\n      value={state.text}\n      oninput={event(\"type\")}\n      oncreate={focus()}\n    />\n  </main>\n);\n\nwithFx(fx)(app)(state, actions, view, document.body);\n```\n\n### `keydown`\n\n```js\nkeydown = (action: string) => EffectTuple\n```\n\nDescribes an effect that will capture [keydown](https://developer.mozilla.org/en-US/docs/Web/Events/keydown) events for your entire document. The [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) will be provided as the action `data`.\n\nExample:\n\n```js\nimport { withFx, keydown } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  init: () => keydown(\"keyPressed\"),\n  keyPressed: keyEvent => {\n    // keyEvent has the props of the KeyboardEvent\n  }\n}\n\nwithFx(app)(state, actions).init()\n```\n\n### `keyup`\n\n```js\nkeyup = (action: string) => EffectTuple\n```\n\nDescribes an effect that will capture [keyup](https://developer.mozilla.org/en-US/docs/Web/Events/keyup) events for your entire document. The [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) will be provided as the action `data`.\n\nExample:\n\n```js\nimport { withFx, keyup } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  init: () => keyup(\"keyReleased\"),\n  keyReleased: keyEvent => {\n    // keyEvent has the props of the KeyboardEvent\n  }\n}\n\nwithFx(app)(state, actions).init()\n```\n\n### `random`\n\n```js\nrandom = (action: string, min?: number, max?: number) => EffectTuple\n```\n\nDescribes an effect that will call an action with a [randomly generated number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) within a range. If provided the range will be `[min, max)` or else the default range is `[0, 1)`. The random number will be provided as the action `data`.\n\nUse [`Math.floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor) if you want a random integer instead of a floating-point number. Remember the range will be `max` exclusive, so use your largest desired int + 1.\n\nExample:\n\n```js\nimport { withFx, random } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  // We use the max of 7 to include all values of 6.x\n  foo: () => random(\"rollDie\", 1, 7),\n  rollDie: randomNumber => {\n    const roll = Math.floor(randomNumber)\n    // roll will be an int from 1-6\n  }\n}\n\nwithFx(app)(state, actions).foo()\n```\n\n### `debounce`\n\n```js\ndebounce = (wait: number, action: string, data?: any) => EffectTuple\n```\n\nDescribes an effect that will call an action after waiting for a delay to pass. The delay will be reset each time the action is called.\n\nExample:\n\n```js\nimport { withFx, debounce } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  waitForLastInput: input => debounce(\n    500,\n    \"search\",\n    { query: input }\n  ),\n  search: data => {\n    /*\n      This action will run after waiting\n      for 500ms since the last call\n      It will only be called once\n      data will have { query: \"hyperapp\" }\n    */\n  }\n}\n\nconst main = withFx(app)(state, actions)\nmain.waitForLastInput(\"hyper\")\nmain.waitForLastInput(\"hyperapp\")\n```\n\n### `throttle`\n\n```js\nthrottle = (rate: number, action: string, data?: any) => EffectTuple\n```\n\nDescribes an effect that will call an action at a maximum rate. Where `rate` is one call per `rate` miliseconds\n\nExample:\n\n```js\nimport { withFx, throttle } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  doExpensiveAction: param => throttle(\n    500,\n    \"calculate\",\n    { foo: param }\n  ),\n  calculate: data => {\n    /*\n      This action will only run once per 500ms\n      It will be run twice\n      data will receive { foo: \"foo\" } and { foo: \"baz\" }\n    */\n  }\n}\n\nconst main = withFx(app)(state, actions)\nmain.doExpensiveAction(\"foo\")\nmain.doExpensiveAction(\"bar\")\nsetTimeout(function() {\n  main.doExpensiveAction(\"baz\")\n})\n```\n\n### `fxIf`\n\n```js\nEffectConditional = [boolean, EffectTuple]\neffectsIf = EffectConditional[] => EffectTuple[]\n```\n\nConvert an array of `[boolean, EffectTuple]`s into a new array of effects where the boolean evaluated to true. This provides compact syntatic sugar for conditionally firing effects.\n\nExample:\n\n```js\nimport { withFx, fxIf, action } from \"@hyperapp/fx\"\n\nconst state = {\n  // ...\n}\n\nconst actions = {\n  foo: () => ({ running }) =>\n    fxIf([\n      [true, action(\"always\")],\n      [false, action(\"never\")],\n      [running, action(\"ifRunning\")],\n      [!running, action(\"ifNotRunning\")]\n    ])\n}\n\nwithFx(app)(state, actions).foo()\n```\n\n## License\n\nHyperapp FX is MIT licensed. See [LICENSE](LICENSE.md).\n","/src/index.js":"export { withFx } from \"./withFx\"\nexport * from \"./fxCreators\"\nexport { fxIf } from \"./fxIf\"\n","/src/withFx.js":"import { assign } from \"./utils.js\"\nimport makeDefaultFx from \"./makeDefaultFx\"\n\nvar isFx = Array.isArray\nvar isFn = function(value) {\n  return typeof value === \"function\"\n}\n\nfunction getActionNamed(actions, name) {\n  function getNextAction(partialActions, paths) {\n    var nextAction = partialActions[paths[0]]\n    if (!nextAction) {\n      throw new Error(\"couldn't find action: \" + name)\n    }\n    return paths.length === 1\n      ? nextAction\n      : getNextAction(nextAction, paths.slice(1))\n  }\n  return getNextAction(actions, name.split(\".\"))\n}\n\nfunction runIfFx(actions, currentEvent, maybeFx, fx) {\n  if (!isFx(maybeFx)) {\n    // Not an effect\n    return maybeFx\n  } else if (isFx(maybeFx[0])) {\n    // Run an array of effects\n    for (var i in maybeFx) {\n      runIfFx(actions, currentEvent, maybeFx[i], fx)\n    }\n  } else if (maybeFx.length) {\n    // Run a single effect\n    var getAction = getActionNamed.bind(null, actions)\n    var type = maybeFx[0]\n    var props = assign(maybeFx[1], { event: currentEvent })\n    var fxRunner = fx[type]\n    if (isFn(fxRunner)) {\n      fxRunner(props, getAction)\n    } else {\n      throw new Error(\"no such fx type: \" + type)\n    }\n  }\n}\n\nfunction enhanceActions(actionsTemplate, fx) {\n  return Object.keys(actionsTemplate || {}).reduce(function(\n    otherActions,\n    name\n  ) {\n    var action = actionsTemplate[name]\n    otherActions[name] = isFn(action)\n      ? function(data) {\n          return function(state, actions) {\n            var result = action(data)\n            result = isFn(result) ? result(state, actions) : result\n            return runIfFx(actions, null, result, fx)\n          }\n        }\n      : enhanceActions(action, fx)\n    return otherActions\n  },\n  {})\n}\n\nfunction handleEventFx(actions, currentFx, fx) {\n  return function(currentEvent) {\n    runIfFx(actions, currentEvent, currentFx, fx)\n  }\n}\n\nfunction makeEnhancedView(view, fx) {\n  function patchVdomFx(actions, vdom) {\n    if (typeof vdom === \"object\") {\n      for (var key in vdom.attributes) {\n        var maybeFx = vdom.attributes[key]\n        if (isFx(maybeFx)) {\n          vdom.attributes[key] = handleEventFx(actions, maybeFx, fx)\n        }\n      }\n      for (var i in vdom.children) {\n        if (isFn(vdom.children[i])) {\n          vdom.children[i] = makeEnhancedView(vdom.children[i], fx)\n        } else {\n          patchVdomFx(actions, vdom.children[i], fx)\n        }\n      }\n    }\n  }\n  return function(state, actions) {\n    var vdom = view(state, actions)\n    patchVdomFx(actions, vdom, fx)\n    return vdom\n  }\n}\n\nfunction makeFxApp(fx, nextApp) {\n  return function(initialState, actionsTemplate, view, container) {\n    var enhancedActions = enhanceActions(actionsTemplate, fx)\n    var enhancedView = makeEnhancedView(view, fx)\n\n    var appActions = nextApp(\n      initialState,\n      enhancedActions,\n      enhancedView,\n      container\n    )\n    return appActions\n  }\n}\n\nexport function withFx(fxOrApp) {\n  var fx = makeDefaultFx()\n  if (typeof fxOrApp === \"function\") {\n    return makeFxApp(fx, fxOrApp)\n  } else {\n    for (var name in fxOrApp) {\n      fx[name] = fxOrApp[name]\n    }\n    return function(nextApp) {\n      return makeFxApp(fx, nextApp)\n    }\n  }\n}\n","/src/fxCreators.js":"import {\n  ACTION,\n  FRAME,\n  DELAY,\n  TIME,\n  LOG,\n  HTTP,\n  EVENT,\n  KEY_DOWN,\n  KEY_UP,\n  RANDOM,\n  DEBOUNCE,\n  THROTTLE\n} from \"./fxTypes\"\n\nexport function action(name, data) {\n  return [\n    ACTION,\n    {\n      name: name,\n      data: data\n    }\n  ]\n}\n\nexport function frame(action) {\n  return [\n    FRAME,\n    {\n      action: action\n    }\n  ]\n}\n\nexport function delay(duration, action, data) {\n  return [\n    DELAY,\n    {\n      duration: duration,\n      action: action,\n      data: data\n    }\n  ]\n}\n\nexport function time(action) {\n  return [\n    TIME,\n    {\n      action: action\n    }\n  ]\n}\n\nexport function log() {\n  return [\n    LOG,\n    {\n      args: arguments\n    }\n  ]\n}\n\nexport function http(url, action, options) {\n  return [\n    HTTP,\n    {\n      url: url,\n      action: action,\n      options: options\n    }\n  ]\n}\n\nexport function event(action) {\n  return [\n    EVENT,\n    {\n      action: action\n    }\n  ]\n}\n\nexport function keydown(action) {\n  return [\n    KEY_DOWN,\n    {\n      action: action\n    }\n  ]\n}\n\nexport function keyup(action) {\n  return [\n    KEY_UP,\n    {\n      action: action\n    }\n  ]\n}\n\nexport function random(action, min, max) {\n  return [\n    RANDOM,\n    {\n      action: action,\n      min: min || 0,\n      max: max || 1\n    }\n  ]\n}\n\nexport function debounce(wait, action, data) {\n  return [\n    DEBOUNCE,\n    {\n      wait: wait,\n      action: action,\n      data: data\n    }\n  ]\n}\n\nexport function throttle(rate, action, data) {\n  return [\n    THROTTLE,\n    {\n      rate: rate,\n      action: action,\n      data: data\n    }\n  ]\n}\n","/src/fxIf.js":"export function fxIf(fxSpecs) {\n  return fxSpecs\n    .filter(function(fxSpec) {\n      // first element is the conditional\n      return fxSpec[0]\n    })\n    .map(function(fxSpec) {\n      // second element is the effect to include\n      return fxSpec[1]\n    })\n}\n","/src/utils.js":"export function assign(source, assignments) {\n  var result = {},\n    i\n  for (i in source) result[i] = source[i]\n  for (i in assignments) result[i] = assignments[i]\n  return result\n}\n\nexport function omit(object, keys) {\n  var copy = {}\n  Object.keys(object)\n    .filter(function(key) {\n      return keys.indexOf(key) === -1\n    })\n    .forEach(function(key) {\n      copy[key] = object[key]\n    })\n  return copy\n}\n","/src/makeDefaultFx.js":"import {\n  ACTION,\n  FRAME,\n  DELAY,\n  TIME,\n  LOG,\n  HTTP,\n  EVENT,\n  KEY_DOWN,\n  KEY_UP,\n  RANDOM,\n  DEBOUNCE,\n  THROTTLE\n} from \"./fxTypes\"\nimport { assign, omit } from \"./utils.js\"\n\nexport default function makeDefaultFx() {\n  var fx = {}\n\n  fx[ACTION] = function(props, getAction) {\n    getAction(props.name)(props.data)\n  }\n\n  fx[FRAME] = function(props, getAction) {\n    requestAnimationFrame(function(time) {\n      getAction(props.action)(time)\n    })\n  }\n\n  fx[DELAY] = function(props, getAction) {\n    setTimeout(function() {\n      getAction(props.action)(props.data)\n    }, props.duration)\n  }\n\n  fx[TIME] = function(props, getAction) {\n    getAction(props.action)(performance.now())\n  }\n\n  fx[LOG] = function(props) {\n    // eslint-disable-next-line no-console\n    console.log.apply(null, props.args)\n  }\n\n  fx[HTTP] = function(props, getAction) {\n    var options = assign(\n      {\n        response: \"json\",\n        error: props.action\n      },\n      props.options\n    )\n    var fetchOptions = omit(options, [\"response\", \"error\"])\n    fetch(props.url, fetchOptions)\n      .then(function(response) {\n        if (!response.ok) {\n          throw response\n        }\n        return response\n      })\n      .then(function(response) {\n        return response[options.response]()\n      })\n      .then(function(result) {\n        getAction(props.action)(result)\n      })\n      .catch(function(error) {\n        getAction(options.error)(error)\n      })\n  }\n\n  fx[EVENT] = function(props, getAction) {\n    getAction(props.action)(props.event)\n  }\n\n  fx[KEY_DOWN] = function(props, getAction) {\n    document.onkeydown = function(keyEvent) {\n      getAction(props.action)(keyEvent)\n    }\n  }\n\n  fx[KEY_UP] = function(props, getAction) {\n    document.onkeyup = function(keyEvent) {\n      getAction(props.action)(keyEvent)\n    }\n  }\n\n  fx[RANDOM] = function(props, getAction) {\n    var randomValue = Math.random() * (props.max - props.min) + props.min\n    getAction(props.action)(randomValue)\n  }\n\n  var debounceTimeouts = {}\n  fx[DEBOUNCE] = function(props, getAction) {\n    return (function(props, getAction) {\n      clearTimeout(debounceTimeouts[props.action])\n      debounceTimeouts[props.action] = setTimeout(function() {\n        getAction(props.action)(props.data)\n      }, props.wait)\n    })(props, getAction)\n  }\n\n  var throttleLocks = {}\n  fx[THROTTLE] = function(props, getAction) {\n    return (function(props, getAction) {\n      if (!throttleLocks[props.action]) {\n        getAction(props.action)(props.data)\n        throttleLocks[props.action] = true\n        setTimeout(function() {\n          throttleLocks[props.action] = false\n        }, props.rate)\n      }\n    })(props, getAction)\n  }\n\n  return fx\n}\n","/src/fxTypes.js":"export var ACTION = \"action\"\nexport var FRAME = \"frame\"\nexport var DELAY = \"delay\"\nexport var TIME = \"time\"\nexport var LOG = \"log\"\nexport var HTTP = \"http\"\nexport var EVENT = \"event\"\nexport var KEY_DOWN = \"keydown\"\nexport var KEY_UP = \"keyup\"\nexport var RANDOM = \"random\"\nexport var DEBOUNCE = \"debounce\"\nexport var THROTTLE = \"throttle\"\n"},"dependencies":{},"peerDependencies":{},"unresolved":{}}}}}